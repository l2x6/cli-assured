= CLI Assured

https://github.com/l2x6/cli-assured/blob/main/LICENSE[image:https://img.shields.io/github/license/l2x6/cli-assured.svg[License]]
https://central.sonatype.com/artifact/org.l2x6.cli-assured/cli-assured[image:https://img.shields.io/maven-central/v/org.l2x6.cli-assured/cli-assured.svg[Maven
Central]]

A Java DSL for testing command line applications.

Requires Java 8+ for basic usage,
but Java 9+ is better if you need newer Process API for accessing PID or child processes.

== Maven coordinates

[source,xml]
----
<dependency>
  <groupId>org.l2x6.cli-assured</groupId>
  <artifactId>cli-assured</artifactId>
  <version><!-- Use the latest --></version>
</dependency>
----

Find the latest version on https://central.sonatype.com/artifact/org.l2x6.cli-assured/cli-assured[Maven Central].

== Usage

=== Basic syntax

Test an executable available in `PATH`

[source,java]
----
import org.l2x6.cli.assured.CliAssured;

CliAssured
    .command("echo", "CLI Assured rocks!")
    .stderrToStdout() // redirect stderr to stdout
    .then()
        // Assertions for stdout
        // The same can be done with stderr(), unless you called stderrToStdout()
        .stdout()
            .hasLines("CLI Assured rocks!")
            .hasLinesContaining("rocks")
            .hasLinesMatching("CLI.*rocks")
            .doesNotHaveLinesContainingCaseInsensitive("error")
            .log() // Pass every line to org.l2x6.cli.assured.stdout logger
            .hasLineCount(1)
            .redirect(Path.of("hello.txt")) // redirect the output to hello.txt
        .exitCodeIs(0) // could be omitted as exit code 0 is enforced by default
    .execute() // start the process and await its termination
    .assertSuccess(); // Report all assertion errors
----

=== Given-when-then

If you are a fan of Behavior-Driven testing, CLI Assert has some syntactic sugar for you:

[source,java]
----
import org.l2x6.cli.assured.CliAssured;

CliAssured
    .given()
        .env("MESSAGE", "CLI Assured rocks!")
    .when()
        .command("sh", "-c",
                    "echo $MESSAGE;"
                  + "echo Really! 1>&2")
    .then()
        .stdout()
            .hasLines("CLI Assured rocks!")
            .hasLineCount(1)
        .stderr()
            .hasLines("Really!")
            .hasLineCount(1)
        .exitCodeIs(0)
    .execute()
    .assertSuccess();
----

=== `stdin`

You can pass a string or file to `stdin` of the command under test:

[source,java]
----
import org.l2x6.cli.assured.CliAssured;

CliAssured
    .given()
        .stdin("Hello world!")
        // or alternatively:
        // .stdin(Path.of("my-input-file.txt"))
    .when()
        .command("cat")
    .then()
        .stdout()
            .hasLines("Hello world!")
            .hasLineCount(1)
    .execute()
    .assertSuccess();
----

You can also write directly to the raw `OutputStream` representing the `stdin` of the command under test:

[source,java]
----
import org.l2x6.cli.assured.CliAssured;

CliAssured
    .given()
        .stdin((OutputStream stdin) -> {
            try {
                stdin.write("Hello world!".getBytes(StandardCharsets.UTF_8));
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        })
    .when()
        .command("cat")
    .then()
        .stdout()
            .hasLines("Hello world!")
            .hasLineCount(1)
    .execute()
    .assertSuccess();
----

=== `CliAssured.java()` - call the `java` executable of the current JVM

Sometimes it comes in handy to call the `java` executable of the current JVM.

For example

[source,java]
----
import org.l2x6.cli.assured.CliAssured;

CliAssured
    .java()
        .args("-jar", "path/to/my.jar")
    .execute()
    .assertSuccess();
----

Or if you want to compile and run a single java file, such as

[source,java]
.Hello.java
----
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello " + args[0]);
    }
}
----

it can be done as follows

[source,java]
----
import org.l2x6.cli.assured.CliAssured;
...

CliAssured
    .java()
       .args("path/to/Hello.java", "Joe")
    .then()
        .stdout()
            .hasLines("Hello Joe")
    .execute()
    .assertSuccess();
----

=== Test long running processes

As long as the application under test is expected to terminate by itself,
it is fine to use `.execute().assertSuccess()` as we did in several examples above.

On the other hand, when testing some long running process, such as application server or a docker container,
you typically want to

* Run the command starting the service
* Await it being up and running
* Perform some assertions
* Shut down the service

Here is a commented snippet suitable for such situations:

[source,java]
----
import org.l2x6.cli.assured.CliAssured;
import org.l2x6.cli.assured.CommandProcess;
import org.l2x6.cli.assured.await.Await;
import org.l2x6.cli.assured.await.Await.LineAwait;
...

// Define an Await that will wait for first line on stdout matching the given regular expression
final LineAwait<Integer> awaitPort = Await
        .lineMatching("listening on port: (\\d+)")
        .map(Integer::parseInt); // transform the string matching the (\\d+) group to int

try (CommandProcess proc = CliAssured.command(/* Your command for starting the server comes here ... */)
            .then()
                .stdout()
                    .await(awaitPort)
                    .log()
                .stderr()
                    .log()
            .start()) {

    // Wait at most for 10 seconds for the port message on stdout
    int port = awaitPort.await(Duration.ofSeconds(10));

    // Now the server has started - we can perform some tests requiring the port
    RestAssured.get("http://localhost:" + port)
            .then()
            .statusCode(200);

} // proc gets auto-closed here
----

The default auto-close behavior of `CommandProcess` can be characterized as follows:

* `java.lang.Process.destroy()` is called on the main process
* On Java 9+, any descendant processes returned by `process.toHandle().descendants()` are also closed
  using `java.lang.ProcessHandle.destroy()`
* On Java 8, only the main process is destroyed

Use the following methods to customize the auto-closing behavior of
`org.l2x6.cli.assured.CommandProcess`:

* `CliAssured.command(...).autoCloseWithoutDescendants()` to avoid closing descendant processes
* `CliAssured.command(...).autoCloseForcibly()` to close the main and descendant processes using
  `java.lang.Process.destroyForcibly()` and `java.lang.ProcessHandle.destroyForcibly()` respectively
* `CliAssured.command(...).autoCloseTimeout(Duration)` to wait at most for the specified `Duration` after `destroy()`
  or `destroyForcibly()` was called on main process and possibly on its descendant processes until the main process
  reports its state as terminated.

== `mvn-assured` - a Java DSL for invoking an testing Maven

`mvn-assured` is a sibling of CLI assured for installing and invoking Maven.

=== Maven coordinates

[source,xml]
----
<dependency>
  <groupId>org.l2x6.cli-assured</groupId>
  <artifactId>mvn-assured</artifactId>
  <version><!-- Use the latest --></version>
</dependency>
----

Find the latest version on https://central.sonatype.com/artifact/org.l2x6.cli-assured/mvn-assured[Maven Central].

=== Usage

[source,java]
----
Mvn.version("3.9.11")
    .installIfNeeded() // installs Maven from
                       // https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.11/apache-maven-3.9.11-bin.zip
                       // to ~/.m2/wrapper/dists/apache-maven-3.9.11/a2d47e15
                       // much like Maven Wrapper would do.

    .args("--version") // Returns an org.l2x6.cli.assured.CommandSpec,
                       // so the rest is a standard cli-assured code
    .then()
        .stdout()
            .hasLines("Apache Maven 3.9.11 (3e54c93a704957b63ee3494413a2b544fd3d825b)")
    .execute()
    .assertSuccess();
----

Or alternatively,

[source,java]
----
Mvn.fromMvnw() // Find .mvn/wrapper/maven-wrapper.properties
                             // under the nearest ancestor,
                             // extract the distribution URL from there
                             // find Maven version from the distribution URL
                             // and use all of that to create a new Mvn instance

    .installIfNeeded() // You can omit this, if you are sure mvnw was run before

    .args("--version") // Returns an org.l2x6.cli.assured.CommandSpec,
                       // so the rest is a standard cli-assured code
    .then()
        .stdout()
            .hasLines("Apache Maven 3.9.11 (3e54c93a704957b63ee3494413a2b544fd3d825b)")
    .execute()
    .assertSuccess();
----
